---
layout:     post
title:      Java 设计模式之适配器模式
subtitle:   Java、设计模式、适配器模式
date:       2018-10-09
author:     zchen
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - design pattern
---

### 一、了解适配器模式

**1.1 什么是适配器模式**

适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原来接口不兼容的类可以合作无间。适配器模式有两种：“对象”适配器和“类”适配器。

这个模式可以通过创建适配器进行接口转换，让不兼容的接口变得兼容。这可以让客户从实现的接口解耦。如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。

![这里写图片描述 ](http://pflcp4mcc.bkt.clouddn.com/20180125145202890.png)

**1.2 适配器模式组成结构**

 - 客户 (Client)：客户类。
 - 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
 -  适配者（Adaptee）：需要适配的类或适配者类。
 - 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

**1.3 适配器模式 UML 图解**

（1）“对象”适配器

![这里写图片描述 ](http://pflcp4mcc.bkt.clouddn.com/20180125113920856.png)

这个适配器模式充满着良好的 OO 设计原则：使用对象组合，以修改的接口包装备被适配者；这样做还有一个优点：那就是被适配者的任何子类，都可以搭配着适配器使用。

（2）“类”适配器

![这里写图片描述 ](http://pflcp4mcc.bkt.clouddn.com/20180125114727000.png)

看起来“类”适配器和“对象”适配器很类似，唯一的差别就是 Adapter 继承了 Target 与 Adaptee。所以“类”适配器必须要使用多重继承才能实现，在 Java  中这是不可能的。所以这里我们主要介绍“对象”适配器。

**1.4 适配器模式应用场景**

 - 系统需要使用现有的类，而这些类的接口不符合系统的需要。 
 - 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 
 - 需要一个统一的输出接口，而输入端的类型不可预知。


### 二、适配器模式具体应用

**2.1 问题描述**

以假乱真：如果它走起路来像一只鸭子，叫起来像一只鸭子。那么它可能是一只包装了鸭子类适配器的火鸡。

现在你有一个鸭子 (Duck) 接口，一个火鸡 (Turkey) 接口。想让你创建一个鸭子对象，但是现在你只有一只火鸡，怎么办呢？于是你想到用这只火鸡来假扮鸭子。

**2.2 代码实现 (“对象”适配器模式)**

目标鸭子 (Duck) 接口

```java
package com.jas.adapter;

/**
 * 鸭子接口中定义了抽象两个方法，分别是，鸭子“呱呱叫”和鸭子会飞
 */
public interface Duck {
    void quack();
    void fly();
}
```
火鸡 (Turkey) 接口

```java
package com.jas.adapter;

/**
 * 火鸡接口中定义了两个抽象方法，分别是火鸡“咯咯叫”和火鸡会飞
 */
public interface Turkey {
    void gobble();
    void fly();
}
```
野生火鸡 (WildTurkey) 类

```java
package com.jas.adapter;

/**
 * 实现了 Turkey 接口中的两个方法
 */
public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println("Gobble gobble!");
    }

    @Override
    public void fly() {
        System.out.println("I'm flying a short distance!");
    }
}
```
适配器 TurkeyAdapter  类

```java
package com.jas.adapter;

/**
 * 适配器类，实现了 Duck 接口，目的将火鸡转换成鸭子，以假乱真
 */
public class TurkeyAdapter implements Duck {
    Turkey turkey;

    /**
     * 通过构造方法，获得适配对象实例化的引用
     * 
     * @param turkey 适配者对象
     */
    public TurkeyAdapter(Turkey turkey){
        this.turkey = turkey;
    }
    
    @Override
    public void quack() {
        turkey.gobble();
    }

    @Override
    public void fly() {
        // 由于火鸡的飞行距离较鸭子近，为了伪装成鸭子，所以让它飞三次来对应鸭子的飞行距离
        for (int i = 0; i < 3; i++) {
            turkey.fly();
        }
    }
}
```
测试 DuckTestDrive 类

```java
package com.jas.adapter;

public class DuckTestDrive {
    public static void main(String[] args) {
        
        WildTurkey wildTurkey = new WildTurkey();
        // 将火鸡包装进一个火鸡适配器中，使它看起来像一只鸭子
        TurkeyAdapter turkeyAdapter = new TurkeyAdapter(wildTurkey);  
        
        System.out.println("\nThe TurkeyAdapter says ...");
        turkeyAdapter.quack();
        turkeyAdapter.fly();
    }
}

     /**
     * 输出 
     * The TurkeyAdapter says ...
     * Gobble gobble!
     * I'm flying a short distance!
     * I'm flying a short distance!
     * I'm flying a short distance!
     * 
     */
```

### 三、适配器模式总结

 - 适配器将一个对象包装起来用以改变其接口。
 - 当需要使用一个现有的类而其接口并不符合你的需求时，可以使用适配器。
 - 实现一个适配器可能会花一番功夫，可能也会毫不费力，原因是有其目标接口的大小与复杂度决定。
 - 适配器模式有两种形式：“类”适配器与“对象适配器”，类适配器需要使用到多重继承，所以在 Java 中并不适用。

#### 参考资料
《Head First 设计模式》 